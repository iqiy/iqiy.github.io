---                                                                                
layout:     post
title:      "图像处理基础（四）" 
subtitle:   "CV面试题"
date:       2020-09-06 17:20:00
author:     "QIY"
header-img: "img/IAP.png"
header-mask: 0.3 
catalog:    true
tags:
    - image processing 
---
> 图像处理 的学习基本上是学十得一。稳扎稳打再来一次
* TOC
{:toc}
# 1.  **常见的模型加速方法**
深度学习模型加速技术就是以“多快好省”为目标，试图从计算优化、系统优化以及硬件优化等多方面提升深度学习模型在训练和推理阶段的速度。
![](/img/in-post/200906_cv/2ce0b504966ca4659625294370afa3ae.png)
# **2. 目标检测里如何有效解决常见的前景少背景多的问题**
采用Focal Loss或OHEM进行负样本挖掘，加大Hard Example损失权重，
训练时只利用Ground Truth周边的Prior
Boxes进行训练，忽略其他背景区域，只考虑困难背景区域。
# **3. 目标检测里有什么情况是SSD、YOLOv3、Faster
R-CNN等所不能解决的，假设网络拟合能力无限强**
# **4. ROIPool和ROIAlign的区别**
**ROIAlign是在ROIPool基础上做的改进**
改进：将最近邻插值换为双线性插值，使得即使缩放后坐标不能刚好为整数，也能通过插值得到浮点数处的值处理得到pooling后的值。
如下图所示：ROIAlign中池化的块允许为浮点数，通过双线性插值得到尺寸为浮点数的块池化后的结果，保证了空间精度**。**
# **5. 介绍常见的梯度下降优化方法**
梯度下降法是最小化目标函数的一种方法，其中，为模型参数，梯度下降法利用目标函数关于参数的梯度的反方向更新参数。学习率决定达到最小值或者局部最小值过程中所采用的步长的大小。即，我们沿着目标函数的斜面下降的方向，直到到达谷底。
## **5.1 Batch gradient descent**
![](/img/in-post/200906_cv/9964b2c6845eaac4f220a7dcba20389e.png)
批梯度下降，对所有的样本计算梯度后求平均，并更新参数。
因为在执行每次更新时，我们需要在整个数据集上计算所有的梯度，所以批梯度下降法的速度会很慢，同时，批梯度下降法无法处理超出内存容量限制的数据集。批梯度下降法同样也不能在线更新模型，即在运行的过程中，不能增加新的样本。
对于凸误差函数，批梯度下降法能够保证收敛到全局最小值，对于非凸函数，则收敛到一个局部最小值。
## **5.2 SGD**
随机梯度下降，对每个样本计算梯度，并更新一次参数。
![](/img/in-post/200906_cv/5dacdd8728daac82fe2c5b4a6dadef1a.png)
SGD的运行速度更快
可以用于在线学习
SGD以高方差频繁地更新，导致目标函数出现剧烈波动。
与批梯度下降法的收敛会使得损失函数陷入局部最小相比，由于SGD的波动性，一方面，波动性使得SGD可以跳到新的和潜在更好的局部最优。另一方面，这使得最终收敛到特定最小值的过程变得复杂，因为SGD会一直持续波动。然而，已经证明当我们缓慢减小学习率，SGD与批梯度下降法具有相同的收敛行为，对于非凸优化和凸优化，可以分别收敛到局部最小值和全局最小值。
## **5.3 mini-batch GD**
小批量梯度下降法最终结合了上述两种方法的优点，在每次更新时使用个小批量训练样本
减少参数更新的方差，这样可以得到更加稳定的收敛结果
可以利用最新的深度学习库中高度优化的矩阵优化方法，高效地求解每个小批量数据的梯度。
原始的梯度下降方法有以下问题：
在梯度平缓的维度下降非常慢，在梯度险峻的维度容易抖动
容易陷入局部极小值或鞍点。Zero gradient,gradient descent gets stuck
（在高维空间中，鞍点比局部极小值更容易出现）
选择一个合适的学习率可能是困难的。学习率太小会导致收敛的速度很慢，学习率太大会妨碍收敛，导致损失函数在最小值附近波动甚至偏离最小值。
学习率调整试图在训练的过程中通过例如退火的方法调整学习率，即根据预定义的策略或者当相邻两代之间的下降值小于某个阈值时减小学习率。然而，策略和阈值需要预先设定好，因此无法适应数据集的特点
对所有的参数更新使用同样的学习率。如果数据是稀疏的，同时，特征的频率差异很大时，我们也许不想以同样的学习率更新所有的参数，对于出现次数较少的特征，我们对其执行更大的学习率。
![](/img/in-post/200906_cv/988af77daf6196456499677099d3e12c.png)
## **5.4 Moment**
在每次下降时都加上之前运动方向上的动量
在梯度缓慢的维度下降更快，在梯度险峻的维度减少抖动。
对于在梯度点处具有相同的方向的维度，其动量项增大，对于在梯度点处改变方向的维度，其动量项减小。因此，我们可以得到更快的收敛速度，同时可以减少摇摆。
![](/img/in-post/200906_cv/972f407a730f70b2f2c64766dd78fe3c.png)
v表示velocity 速率，即在原先运动的方向上再往前走一段
![](/img/in-post/200906_cv/8a805a3e7413d2a71bd58a7c202e7d90.png)
## **5.5 Nesterov**
我们利用动量项算来更新参数。通过计算能够告诉我们参数未来位置的一个近似值（梯度并不是完全更新），这也就是告诉我们参数大致将变为多少。通过计算关于参数未来的近似位置的梯度，而不是关于当前的参数的梯度，我们可以高效的求解。
![](/img/in-post/200906_cv/661cd705299c4a2ff0342f43ad5727ab.png)
![](/img/in-post/200906_cv/4f12b0041e2fc28a13d3f2413732f932.png)
![](/img/in-post/200906_cv/88ba56a5a360b5e9200b77ba03a86896.png)
动量法首先计算当前的梯度值（图中的小的蓝色向量），然后在更新的累积梯度（大的蓝色向量）方向上前进一大步，Nesterov加速梯度下降法NAG首先在先前累积梯度（棕色的向量）方向上前进一大步，计算梯度值，然后做一个修正（绿色的向量）。这个具有预见性的更新防止我们前进得太快，同时增强了算法的响应能力，这一点在很多的任务中对于RNN的性能提升有着重要的意义。
## **5.6 Adagrad**
把每一维度的梯度\^2和记录下来，每次学习率都除以这个和
每一维度的学习率不一样，且都在不断减小
在梯度大的维度，减小下降速度；在梯度小的维度，加快下降速度
让学习率适应参数，对于出现次数较少的特征，我们对其采用更大的学习率，对于出现次数较多的特征，我们对其采用较小的学习率。因此，Adagrad非常适合处理稀疏数据。
Adagrad算法的一个主要优点是无需手动调整学习率
Adagrad的一个主要缺点是它在分母中累加梯度的平方：由于每增加一个正项，在整个训练过程中，累加的和会持续增长。这会导致学习率变小以至于最终变得无限小，在学习率无限小时，Adagrad算法将无法取得额外的信息。
![](/img/in-post/200906_cv/8b576768d7ddbf6324a791c280b2e3c4.png)
Added element-wise scaling of the gradient based on the historical sum of
squares in each dimension
## **5.7 Adadelta**
是Adagrad的一种扩展算法，以处理Adagrad学习速率单调递减的问题。
不是计算所有的梯度平方，Adadelta将计算计算历史梯度的窗口大小限制为一个固定值。
无需设置默认的学习率，因为更新规则中已经移除了学习率。
## **5.8 RMSprop**
同样对AdaGrad的改进
![](/img/in-post/200906_cv/d8e73fe47f31825003ce81ea4019187b.png)
## **5.9 Adam**
结合了Momentum和RMSprop的特点
自适应学习率
![](/img/in-post/200906_cv/f43e5f7cec0b8bfda298d0e2d9ec7984.png)
Bias correction for the fact thatfirst and second momentestimates start at zero
Adam with beta1 = 0.9, beta2 = 0.999, and learning_rate = 1e-3 or 5e-4is a great
starting point for many models!
参考：*https://blog.csdn.net/u012892939/article/details/80785593*
# **6. Detection你觉的还有哪些可做的点**
**转：**
# **7. BGD，SGD，mini-batch GD**
BGD:所有样本跑一次网络后，更新权值。这种方式优点是，精确，和loss
function对应。缺点就是效率不高，慢
SGD：跑一个样本更新一次权值，优点:快，缺点：因为用一个样本就更新权值，很容易就找不到全局最优解。
mini-batch GD：更新跑一定两样本，更新一次权值，结合BGD和SGD综合考虑。
时间消耗：GD \> mini batch GD \> SGD （值越大消耗时间越长）
收敛性稳定情况：GD \> mini batch GD \> SGD （值越大越稳定）
## **7.1 GD(Gradient Descent)**
梯度下降：每次对整个数据集进行训练。
优点：其loss的收敛性好，因为每次参数的调整都考虑到了所有的数据。
缺点：由于深度学习模型的训练依赖于大量的数据，所以每次进行训练都会消耗大量的时间。
## **7.2 SGD(Stochastic Gradient Descent)**
随机梯度下降：每次挑选一个样本进行训练。
优点：由于每次的参数调整仅考虑一个样本数据，所以每次训练都会节省大量时间。
缺点：其loss的收敛性非常不稳定，因为参数的每一次调整仅仅考虑一个样本数据。
## **7.3 mini batch GD**
小批量梯度下降：它是GD和SGD的中和，每次取出batch_size个样本数据来进行训练。
优点：不论是训练过程中的时间消耗方面还是loss的收敛性稳定方面，都不是最差的，当然也不是最好的。
# **8. 人体姿态估计主流的两个做法是啥？简单介绍下**
**top-down：**
CPM
Hourglass
CPN
Simple Baselines
HRNet
MSPN
**bottom-up：**
openpose(多人)
Hourglass+Associative Embedding
HigherHRNet
姿态估计问题可以分为两大类：2D姿态估计和3D姿态估计。顾名思义，前者是为每个关键点预测一个二维坐标
[公式] ；后者是为每个关键点预测一个三维坐标 [公式]
，增加了一维深度信息。本文主要介绍2D姿态估计。
对于2D姿态估计，当下研究的多为多人姿态估计，即每张图片可能包含多个人。解决该类问题的思路通常有两种：top-down和bottom-up：
top-down的思路是首先对图片进行目标检测，找出所有的人；然后将人从原图中crop出来，resize后输入到网络中进行姿态估计。换言之，top-down是将多人姿态估计的问题转化为多个单人姿态估计的问题。
bottom-up的思路是首先找出图片中所有关键点，然后对关键点进行分组，从而得到一个个人。
# **9. 卷积的实现原理以及如何快速高效实现局部weight sharing的卷积操作方式**
原理：https://qiy.net/2020/06/08/DL_CNN/
weight sharing：
权值共享可被用来进行网络模型的压缩加速。若相邻两层之间为全连接，每层有1000个节点，那么这两层之间有1000\*1000个权值（参数）。*对这一百万个权值进行聚类，权值接近的为一类，可以用每个类的均值替换这一类的权值，*这样部分连接（如果他们聚在同一类）将共享相同的权值。如果我们把一百万个数聚成一千类，就可以把参数的个数从一百万降到一千个，模型大小被大幅压缩。
权值共享方案如图所示：
获取为浮点数的权值之后，使用相关聚类方法，*按照大小的相近程度分为不同类别（不同颜色块）*，每个类别只需要保存一个聚类中心的权值，和对应的聚类索引（Index），数据量大幅度减少。在权值更新时进行反向传播，计算每项权值的梯度（Gradient），将之前聚类的同一类别的梯度累加，结合学习率lr（Learning
Rate）进行权值更新。
 
![](/img/in-post/200906_cv/515fa6fc461122d5ac71e89448f8f85e.png)
进行权值共享优化之后的网络模型将会在一定程度上被压缩，例如对于经典网络AlexNet，下表显示出其经过剪枝和权值共享等优化处理之后的压缩效果：
| 层    | 权值大小 | 权值%（剪枝） | 权值bits（剪枝+权值共享） | 索引bits（剪枝+权值共享） | 压缩率       |
|-------|----------|---------------|---------------------------|---------------------------|--------------|
| Conv1 | 35K      | 84%           | 8                         | 4                         | 32.6%        |
| Conv2 | 307K     | 38%           | 8                         | 4                         | 14.5%        |
| Conv3 | 885K     | 35%           | 8                         | 4                         | 13.1%        |
| Conv4 | 663K     | 37%           | 8                         | 4                         | 14.1%        |
| Conv5 | 442K     | 37%           | 8                         | 4                         | 14.0%        |
| Fc6   | 38M      | 9%            | 5                         | 4                         | 3.0%         |
| Fc7   | 17M      | 9%            | 5                         | 4                         | 3.0%         |
| Fc8   | 4M       | 25%           | 5                         | 4                         | 7.3%         |
| 总计  | 61M      | 11%（9倍）    | 5.4                       | 4                         | 3.7%（27倍） |
# **10.
CycleGAN的生成效果为啥一般都是位置不变纹理变化，为啥不能产生不同位置的生成效果**
不同位置咋生成，生成域被固定了。
